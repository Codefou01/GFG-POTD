// Java : 

1. Merge Sort 

class Solution {

   public static Node merge(Node l1, Node l2){
        if(l1 == null) return l2;
        if(l2 == null) return l1;

        if(l1.data <= l2.data){
            l1.next = merge(l1.next,l2);
            return l1;
        }else{
            l2.next = merge(l1,l2.next);
            return l2;
        } 
        
   }
    
    public Node sortli(Node[] li, int st, int end){
        if(st > end) return null;
        if(st == end) return  li[st];

        int mid = st + (end-st)/2 ;
        Node l1 = sortli(li,st,mid);
        Node l2 = sortli(li,mid+1,end);
      
      return merge(l1,l2);
    }

    public Node mergeKLists(Node[] lists) {
       return sortli(lists,0,lists.length-1);        
    }
}


2. Min Heap

class Solution {
    Node mergeKLists(Node[] arr) {
        PriorityQueue<Node> pq = new PriorityQueue<>(new Comparator<Node>() {
            public int compare(Node a, Node b) {
                return a.data - b.data;// 4 - 5 => -1
            }
        });
        
        for (Node node : arr) {
            if (node != null) pq.add(node);
        }
        
        Node dummy = new Node(0);
        Node current = dummy;
        
        while (!pq.isEmpty()) {
            Node node = pq.poll();
            current.next = node;
            current = current.next;
            
            if (node.next != null) pq.add(node.next);
        }
        
        return dummy.next;
    }
}


// C++ Code : 

1. Merge Sort


class Solution {
public:
    Node* merge(Node* l1, Node* l2) {
        if (!l1) return l2;
        if (!l2) return l1;

        if (l1->data <= l2->data) {
            l1->next = merge(l1->next, l2);
            return l1;
        } else {
            l2->next = merge(l1, l2->next);
            return l2;
        }
    }

    Node* sortli(vector<Node*>& li, int st, int end) {
        if (st > end) return nullptr;
        if (st == end) return li[st];

        int mid = st + (end - st) / 2;
        Node* l1 = sortli(li, st, mid);
        Node* l2 = sortli(li, mid + 1, end);

        return merge(l1, l2);
    }

    Node* mergeKLists(vector<Node*>& lists) {
        if (lists.empty()) return nullptr;
        return sortli(lists, 0, static_cast<int>(lists.size()) - 1);
    }
};


2. Min Heap

class Solution {
public:
    struct compare {
        bool operator()(Node* a, Node* b) {
            return a->data > b->data;
        }
    };

   Node* mergeKLists(vector<Node*>& arr) {
        priority_queue<Node*, vector<Node*>, compare> pq;
    
        for (auto node : arr) {
            if (node != nullptr) pq.push(node);
        }
    
        Node* dummy = new Node(0);
        Node* current = dummy;
    
        while (!pq.empty()) {
            Node* node = pq.top(); pq.pop();
            current->next = node;
            current = current->next;
    
            if (node->next) pq.push(node->next);
        }
    
        return dummy->next;
    }

};
